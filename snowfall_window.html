<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Snow Falling Outside Window</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  html,body {
    margin:0;
    height:100%;
    overflow:hidden;
    font-family:sans-serif;
    background:#000;
  }
  #bg {
    position:absolute;
    left:0; top:0;
    width:100%; height:100%;
    object-fit:cover;
    z-index:-2;
  }
  canvas {
    position:absolute;
    left:0; top:0;
    z-index:2;
  }
  /* window glass overlay for subtle shine */
  #glass {
    position:absolute;
    z-index:1;
    pointer-events:none;
    background:linear-gradient(
      120deg,
      rgba(255,255,255,0.06) 0%,
      rgba(255,255,255,0.02) 40%,
      rgba(255,255,255,0.10) 100%
    );
    backdrop-filter: blur(2px);
  }
</style>
</head>
<body>

<!-- Background image of warm living room with fireplace -->
<img id="bg" src="/Users/einav.leyboshor/prom-exp/prom-cli/livingroom.jpg">

<!-- Canvas for snow -->
<canvas id="c"></canvas>

<!-- Slight reflection layer -->
<div id="glass"></div>

<script>
/* ---------- deterministic PRNG ---------- */
function mulberry32(seed) {
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function rand(rng, a, b){ return a + rng() * (b - a); }

/* ---------- canvas ---------- */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let W = canvas.width = window.innerWidth;
let H = canvas.height = window.innerHeight;

/* Define window area where snow falls */
let windowX = 0.15 * W;     // 15% from left
let windowY = 0.10 * H;     // 10% from top
let windowW = 0.70 * W;     // 70% width
let windowH = 0.80 * H;     // 80% height

const glass = document.getElementById("glass");
glass.style.left   = windowX + "px";
glass.style.top    = windowY + "px";
glass.style.width  = windowW + "px";
glass.style.height = windowH + "px";

window.addEventListener("resize", () => {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;

  windowX = 0.15 * W;
  windowY = 0.10 * H;
  windowW = 0.70 * W;
  windowH = 0.80 * H;

  glass.style.left   = windowX + "px";
  glass.style.top    = windowY + "px";
  glass.style.width  = windowW + "px";
  glass.style.height = windowH + "px";
});

/* ---------- draw 1 snow crystal ---------- */
function drawSnowflake(ctx, seed, size) {
  const rng = mulberry32(seed);
  const arms = Math.floor(rand(rng, 4, 10));
  const length = size * rand(rng, 0.6, 1.1);
  const thick = Math.max(1, Math.round(size * rand(rng, 0.03, 0.07)));

  ctx.save();
  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  ctx.strokeStyle = `rgba(220,240,255,0.85)`;
  ctx.fillStyle = ctx.strokeStyle;
  ctx.lineWidth = thick;

  ctx.beginPath();
  ctx.arc(0, 0, size * 0.15, 0, Math.PI*2);
  ctx.fill();

  function arm() {
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(0,-length);
    ctx.stroke();

    const branches = Math.floor(rand(rng, 2, 6));
    for (let i = 1; i <= branches; i++) {
      const t = -length * (i/(branches+1));
      const bl = size * rand(rng, 0.3, 0.6);

      ctx.beginPath();
      ctx.moveTo(0,t);
      ctx.lineTo(-bl, t - bl*0.3);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0,t);
      ctx.lineTo(bl, t - bl*0.3);
      ctx.stroke();
    }
  }

  for (let i=0;i<arms;i++){
    ctx.save();
    ctx.rotate((i/arms)*Math.PI*2);
    arm();
    ctx.restore();
  }

  ctx.restore();
}

/* ---------- snowflake objects ---------- */
const FLAKES = [];
const COUNT = 130;
let globalSeed = 999000;

class Flake {
  constructor(i) {
    this.seed = globalSeed + i;
    this.rng = mulberry32(this.seed);
    this.reset(true);
  }

  reset(initial=false) {
    this.size = rand(this.rng, 8, 32);
    this.x = rand(this.rng, windowX, windowX + windowW);
    this.y = initial ? rand(this.rng, windowY, windowY + windowH) : windowY - this.size;
    this.speed = rand(this.rng, 0.4, 1.3);
    this.drift = rand(this.rng, -0.4, 0.4);
    this.rotation = rand(this.rng, 0, Math.PI*2);
    this.rotationSpeed = rand(this.rng, -0.002, 0.002);
  }

  update() {
    this.y += this.speed;
    this.x += this.drift;
    this.rotation += this.rotationSpeed;

    if (this.y > windowY + windowH + this.size) {
      this.reset(false);
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.globalAlpha = 0.85;
    drawSnowflake(ctx, this.seed, this.size);
    ctx.restore();
  }
}

/* Initialize flakes */
for (let i=0;i<COUNT;i++){
  FLAKES.push(new Flake(i));
}

/* ---------- animation ---------- */
function animate(){
  ctx.clearRect(0,0,W,H);

  for(const f of FLAKES){
    f.update();
    f.draw();
  }

  requestAnimationFrame(animate);
}
animate();

</script>
</body>
</html>
